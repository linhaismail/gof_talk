## 开放封闭原则（OpenClosedPrinciple，OCP）

**软件实体（类、模块、函数等等）应该可以扩展，但不可修改。**

两个特征：
1. 对于扩展是开放的（Open for extension）;
2. 对于更改是封闭的（Closed for modification）。

怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？开放封闭原则。

开放-封闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。

绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。

我们很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动。

在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。

比如，使用client很快完成了加法类，当增加减法类时发现需要修改原来这个client，这就违反了OCP。此时就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承、多态等来隔离具体的加法、减法与client耦合。这时，如果在增加乘法、除法时，就不用去修改client和加法、减法类了，而是增加乘法、除法子类就可以了。

面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。

我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。比如，加法类已经在很多地方使用了，再考虑抽象、分离就很困难了。

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是**可维护、可扩展、可复用、灵活性好**。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。